# GIT

Прежде всего нужно авторизоваться в GIT, набрав в консоли команду git config --global user.name «Ваше имя английскими буквами» git . Здесь и далее завершаем все свои действия в консоли нажатием клавиши Enter.

Также следует указать Вашу почту: config --global user.email ваша почта@example.com

## 4 Шага работы с контролем версий:

- Внести изменения
- Сохранить изменения (Ctrl + S)
- Добавить файл с изменениями (git add)
- Зафиксировать эти изменения (git commit -m "new commit name")

## Команды GIT по работе с файлами и их версиями:

1. git init - инициализировать локальный репозиторий;
2. git status – получить информацию от git о его текущем состоянии;
3. git commit -m “message” – создание коммита;(git commit --amend -m “message” - переименование коммита);
   3.1. git commit -am “message” – добавление всех файлов и создание коммита;(git commit --amend -m “message” - переименование коммита);
   3.2 git commit --amend --no-edit - добавление изменения к коммиту (например можно удалить файл, добавить его в индекс командой "git add .", и добавить изменение в коммит без изменения названия созданного ранее коммита);
4. git log – вывод на экран истории всех коммитов с их хеш-кодами. git log --graph - вывести в терминал графическое отображение ветви коммитов;
   4.1. git log --oneline --graph --all - ;
   4.2. git log origin/nameOfRemoteBranch ^nameOfLocalBranch - показать какие изменения были внесены в удаленную ветку, выводит хэш отличающегося коммита, после чего логично использовать команду git diff 6kjsdfgkasfdmkfdmglkdfdkgdsfmg (Хэш коммита) - показать отличия;
5. git checkout <первые 4 символа нужного коммита> – переход от одного коммита к другому;
6. git checkout master – вернуться к актуальному состоянию и продолжить работу. git checkout (имя ветки) - перейти к указанной ветке;
7. git checkout -b [yourbranchname] - создать новую ветку и сразу переключиться на нее;
8. git checkout branchName^ - переместиться на ветку и выбрать предыдущий коммит;
9. git checkout branchName~4 - переместиться на ветку и выбрать коммит на 4 позиции старше последнего коммита ветки;
10. git add _name_ - добавить файл; (git add . - добавить все файлы в дистрибутиве);
11. git version - узнать версию программы GIT;
12. git diff - отобразить изменения во всех файлах текущей рабочей директории, если таковые были;
    12.1 git diff "filename" - узнать разницу между сохраненным файлом и зафиксированным файлом;
    12.1.1 git diff "filename" "filename2"- узнать разницу между двумя файлами вне зависимости от расположения относительно директории git;
    12.2 git diff 6kjsdfgkasfdmkfdmglkdfdkgdsfmg (Хэш коммита) - показать отличия;
    12.3 git diff 6kjsd 13sad (не менее 4х начальных символов хэшей коммитов) - отобразить разницу между 2-мя конкретными коммитами (последовательность важна, возможно отображение, обратное действительной истории измененеий!!!);
13. git blame "filename" - просмотр каждой строки кода с отображением хэша коммита, автора и времени создания;
14. git restore "filename" - отмена изменений в файле до состояния первоначального;
    14.1 git restore --staged "filename" - отмена помещения файла в индекс git (операция обратна git add "filename");
15. git merge text_formatting - влить в текущую ветку указанную ветку;
16. git branch - отобразить все ветки и узнать текущую ветку;
17. git branch (имя новой ветки) - создать новую ветку;
18. git branch -d (название ветки) - удалить указанную ветку если она полностью влита в родительскую. -D (большая вместо малой) - удаление указанной ветки в любом случае;
19. git branch -f main HEAD~3 - Переместит (принудительно) метку ветки main на три родителя назад от HEAD;
20. git cherry-pick <Commit1> <Commit2> <...> - копировать несколько коммитов на место, где сейчас находишься (HEAD);
21. git reset - отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории";
    21.1 git reset --hard <commit> - удаление всех незакоммиченных изменений. Не удаляет файлы, не добавленные в индекс git, удаляет все последующие коммиты после указанного, делая его крайним, после данной команды не остается незакоммиченых изменений;
    21.2 git reset --soft <commit> - удаление коммитов до состояния указанного коммита без удаления фактических изменений в файлах, с добавлением файлов в индекс git;
    21.3 git reset --mixed <commit> - удаление коммитов до состояния указанного коммита без удаления фактических изменений в файлах, без добавления файлов в индекс git. Эта команда (--mixed) действует по умолчанию, писать её не обязательно, достаточно ввести git reset <commit>;
22. git clean -f - удаляет файлы, не добавленные в индекс после последнего коммита. Файл не получится восставновить!!!;
23. git rm --cached "filename" - удаление файла из отслеживания git, сам файл не удаляется;
24. git tag V1 F4b6n24tdkfgbnv - дает конкретному тегу имя;
25. git describe <ref> - как далеко текущее состояние от ближайшего тега. Если не указать ref, то git будет считать, что указано текущее положение (HEAD);
26. git bisect - утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска;

27. git revert - отменить изменения и поделиться отменёнными изменениями с остальными;
    27.1 git revert --no-commit 3fgfsvxzfzreqt4v2ct32 - отменить конкретный коммит не трогая прочие изменения с возможностью отменения множества коммитов за один раз, а уже потом сделать коммит внесенных изменений;
28. git rebase nameOfBranch - перемещение коммита на указанную ветку
29. git rebase -i - графическая перестановка коммитов с их отключением при надобности

# Команды для работы с удаленными репозиториями:

26. git clone - создаст локальную копию удалённого репозитория;
27. git pull - скачать всё актуальное из удаленного репозитория с одновременным merge;
    27.1 --allow-unrelated-histories -флаг для слияния (pull, merge и тд) веток не имеющих общих предков, веток с разной историей;
28. git push - позволяет отправить нашу версию репозитория на внешний репозиторий. Требует авторизации;
    28.1 git push -u origin master - где "-u" - автоматически связать текущую ветку с удаленной веткой, origin - имя удаленного репозитория, master - ветка которую нужно синхронизировать;
29. git fetch - добавляет в локальный репозиторий изменения из удаленного репозитория синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени, не сливает ветки;
    29.1 git fetch --all - добавляет в локальный репозиторий изменения из всех удаленных репозиториев;
    29.2 git fetch --all --prune позволяет одновременно извлечь изменения из всех удаленных репозиториев и удалить удаленные ветки, которые больше не существуют на удаленных репозиториях;
30. git remote add origin <URL> - добавить удаленный репозиторий и присвоить ему название "origin";
31. git remote -v - показать текущую ветку;
32. git remote -v show - показать текущие ветки (fetch и push);
33. git remote show origin - показать какие локальные ветки связаны с ветками удаленного репозитория;
34. git remote remove origin - отвязать текущий удаленный репозиторий от локального;
    34.1 git remote set-url --add --push all <URL> - добавить путь для push (можно более 1го), при первом применении перезаписывает путь, при повторном - добавляет;

# Stash

35. git stash - используется в Git для временного сохранения незакоммиченных изменений. Это позволяет вам переключиться на другую ветку или применить другие изменения, не фиксируя текущие изменения в коммит.
    Когда вы выполняете git stash, все незакоммиченные изменения сохраняются в стэше, и ваш рабочий каталог становится чистым. Позже вы можете применить сохраненные изменения обратно к вашему рабочему каталогу с помощью команды git stash apply.
36. git stash apply применяет последние сохраненные изменения из стэша к вашему рабочему каталогу. Это позволяет вам вернуть ранее сохраненные изменения обратно к вашему рабочему каталогу без удаления их из стэша;
37. git stash list используется для отображения списка сохраненных изменений в стэше. Когда вы выполняете git stash, ваши незакоммиченные изменения сохраняются в стэше, и команда git stash list позволяет вам просмотреть эти сохраненные изменения;

## Самые частые ошибки в работе с GIT связаны с пропуском одного из 4-х шагов работы с контролем версий [_из списка выше!_](#4-шага-работы-с-контролем-версий)
